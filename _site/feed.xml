<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-11-02T20:25:44+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Microsoft Playground</title><subtitle></subtitle><author><name>Maik van der Gaag</name></author><entry><title type="html">Creating a Logic App API Connection that uses the Managed Identity using Bicep</title><link href="http://localhost:4000/2023/05/creating-a-logic-app-api-connection-that-uses-the-managed-identity-using-bicep/" rel="alternate" type="text/html" title="Creating a Logic App API Connection that uses the Managed Identity using Bicep" /><published>2023-05-11T10:33:30+02:00</published><updated>2023-05-11T10:33:30+02:00</updated><id>http://localhost:4000/2023/05/creating-a-logic-app-api-connection-that-uses-the-managed-identity-using-bicep</id><content type="html" xml:base="http://localhost:4000/2023/05/creating-a-logic-app-api-connection-that-uses-the-managed-identity-using-bicep/">&lt;p&gt;Logic Apps in Azure provides a platform for building workflows that integrate with various services and APIs. When creating Logic Apps, you must often connect securely to other services like the Azure Service Bus and Azure Storage Accounts. Managed Identity is a recommended way to accomplish this.&lt;/p&gt;


&lt;p&gt;Creating these API Connections with Infrastructure as Code isn&apos;t documented well and is challenging to figure out. It took me some time, but I figured it out by looking at the API requests that the portal does.&lt;/p&gt;


&lt;h2 class=&quot;wp-block-heading&quot;&gt;Figuring it out&lt;/h2&gt;


&lt;p&gt;The steps I have taken to figure it out can be applied in different scenarios for Logic Apps but, for example, also on other parts of the portal.&lt;/p&gt;


&lt;ol&gt;&lt;/p&gt;
&lt;li&gt;Create a new Logic App in the Azure portal. &lt;/li&gt;


&lt;li&gt;Add an Identity to the Logic App and give that identity access to the Azure Service you want to use. In this example, we will be using an Azure Service Bus.&lt;/li&gt;


&lt;li&gt;Add a Service Bus trigger to the Logic App and fill in the information below.&lt;/li&gt;
&lt;p&gt;&lt;/ol&gt;


&lt;figure class=&quot;wp-block-image size-full&quot;&gt;&lt;a href=&quot;/assets/archive/2023/05/image.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2023/05/image.png&quot; alt=&quot;&quot; class=&quot;wp-image-6949&quot; /&gt;&lt;/figure&gt;


&lt;ol start=&quot;4&quot;&gt;&lt;/p&gt;
&lt;li&gt;Before you click &apos;create,&apos; open de Edge DevTools (F12) and open de network tab&lt;/li&gt;
&lt;p&gt;&lt;/ol&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2023/05/image-1.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2023/05/image-1-1024x400.png&quot; alt=&quot;&quot; class=&quot;wp-image-7009&quot; /&gt;&lt;/figure&gt;


&lt;ol start=&quot;5&quot;&gt;&lt;/p&gt;
&lt;li&gt;Clear the network items list and click &apos;Create.&apos;&lt;/li&gt;


&lt;li&gt;When the trigger is refreshed, stop the network trace and search for an item that puts information into Azure. When using the Service Bus, the item will look like below.&lt;/li&gt;
&lt;p&gt;&lt;/ol&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2023/05/image-2.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2023/05/image-2-1024x533.png&quot; alt=&quot;&quot; class=&quot;wp-image-7011&quot; /&gt;&lt;/figure&gt;


&lt;ol start=&quot;7&quot;&gt;&lt;/p&gt;
&lt;li&gt;On the right side of the network trace, click on the Payload tab to find the information sent to the Azure Resource Manager. This contains the information that needs to be used in Bicep.&lt;/li&gt;
&lt;p&gt;&lt;/ol&gt;


&lt;figure class=&quot;wp-block-image size-full&quot;&gt;&lt;a href=&quot;/assets/archive/2023/05/image-3.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2023/05/image-3.png&quot; alt=&quot;&quot; class=&quot;wp-image-7013&quot; /&gt;&lt;/figure&gt;


&lt;pre class=&quot;highlight&quot;&gt;{
  &quot;id&quot;: &quot;/subscriptions/f124b668-7e3d-4b53-ba80-09c364def1f3/providers/Microsoft.Web/locations/westeurope/managedApis/servicebus&quot;,
  &quot;parameterValueSet&quot;: {
    &quot;name&quot;: &quot;managedIdentityAuth&quot;,
    &quot;values&quot;: {
      &quot;namespaceEndpoint&quot;: {
        &quot;value&quot;: &quot;sb://azsb-temp.servicebus.windows.net&quot;
      }
    }
  },
  &quot;displayName&quot;: &quot;servicebus-auth&quot;,
  &quot;kind&quot;: &quot;V1&quot;,
  &quot;location&quot;: &quot;westeurope&quot;
}&lt;/pre&gt;


&lt;h2 class=&quot;wp-block-heading&quot;&gt;The outcome in Bicep&lt;/h2&gt;


&lt;p&gt;With the findings, the specific Bicep code can be written. Below are three different API connections that use Managed Identities for the connection.&lt;/p&gt;


&lt;h3 class=&quot;wp-block-heading&quot;&gt;Azure Storage Account API Connection with Managed Identity&lt;/h3&gt;


&lt;pre class=&quot;highlight&quot;&gt;resource storageaccountApiConnectionAuth &apos;Microsoft.Web/connections@2016-06-01&apos;= {
  name: &apos;azuretables-auth&apos;
  location: location
  properties: {
    api: {
      id: &apos;subscriptions/${subscription().subscriptionId}/providers/Microsoft.Web/locations/${location}/managedApis/azuretables&apos;
    }
    parameterValueSet: {
      name: &apos;managedIdentityAuth&apos;
      values: {}
    }
    displayName: &apos;azuretables-auth&apos;
  }
}&lt;/pre&gt;


&lt;h2 class=&quot;wp-block-heading&quot;&gt;Azure Service Bus API Connection with Managed Identity&lt;/h2&gt;


&lt;pre class=&quot;highlight&quot;&gt;resource azla_apiconnection_servicebus_auth &apos;Microsoft.Web/connections@2016-06-01&apos; = {
  name: &apos;servicebus-auth&apos;
  location: location
  properties: {
    displayName: &apos;servicebus-auth&apos;
    api: {
      id: subscriptionResourceId(&apos;Microsoft.Web/locations/managedApis&apos;, location, &apos;servicebus&apos;)
    }
    parameterValueSet: {
      name: &apos;managedIdentityAuth&apos;
      values: {
        namespaceEndpoint: {
          value: &apos;sb://${serviceBus}.servicebus.windows.net/&apos;
        }
      }
    }
  }
}&lt;/pre&gt;


&lt;p&gt;I hope that this helps you in creating epic Bicep files. If you are looking for more information, be sure to look at the following:&lt;/p&gt;


&lt;ul&gt;&lt;/p&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/azure/azure-resource-manager/bicep/learn-bicep?WT.mc_id=AZ-MVP-5004255&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Learn Bicep&lt;/a&gt;&lt;/li&gt;


&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/azure/templates/microsoft.web/connections?pivots=deployment-language-bicep&amp;amp;WT.mc_id=AZ-MVP-5004255&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Microsoft.Web connections&lt;/a&gt;&lt;/li&gt;
&lt;p&gt;&lt;/ul&gt;</content><author><name>Maik van der Gaag</name></author><category term="Azure" /><category term="Development" /><category term="Azure" /><category term="bicep" /><category term="Logic Apps" /><summary type="html">Logic Apps in Azure provides a platform for building workflows that integrate with various services and APIs. When creating Logic Apps, you must often connect securely to other services like the Azure Service Bus and Azure Storage Accounts. Managed Identity is a recommended way to accomplish this.</summary></entry><entry><title type="html">“Exposing Azure App Registrations as Secure APIs: A Guide to Authentication with ‘User Assignments Required’ Turned On”</title><link href="http://localhost:4000/2023/03/unlocking-the-power-of-azure-app-registrations-a-guide-to-exposing-your-app-as-an-api-with-user-assignments-required-turned-on/" rel="alternate" type="text/html" title="“Exposing Azure App Registrations as Secure APIs: A Guide to Authentication with ‘User Assignments Required’ Turned On”" /><published>2023-03-21T11:12:42+01:00</published><updated>2023-03-21T11:12:42+01:00</updated><id>http://localhost:4000/2023/03/unlocking-the-power-of-azure-app-registrations-a-guide-to-exposing-your-app-as-an-api-with-user-assignments-required-turned-on</id><content type="html" xml:base="http://localhost:4000/2023/03/unlocking-the-power-of-azure-app-registrations-a-guide-to-exposing-your-app-as-an-api-with-user-assignments-required-turned-on/">&lt;p&gt;Azure App Registrations are a powerful tool for managing resource access and integrating applications with Microsoft&apos;s cloud services. While these registrations are typically used to grant applications access to other Azure resources, they can also be exposed as APIs, allowing external applications to interact with the registered application&apos;s resources securely.&lt;/p&gt;


&lt;p&gt;In this blog post, we&apos;ll explore exposing an Azure App Registration as an API, including the necessary configuration to authenticate towards the application when the application is configured with &apos;User Assignments Required&apos; turned on. This short guide tells you how to configure this.&lt;/p&gt;


&lt;p&gt;This guide talks about two different Application Registrations.&lt;/p&gt;


&lt;ol type=&quot;1&quot;&gt;&lt;/p&gt;
&lt;li&gt;The application you are authenticating to. (This is the application registered on, for example, an Azure App Service)&lt;/li&gt;


&lt;li&gt;The application you are authenticating with. (This is the application you will use to retrieve data from, for example, an API)&lt;/li&gt;
&lt;p&gt;&lt;/ol&gt;


&lt;h2&gt;Step 1: Expose an API&lt;/h2&gt;


&lt;p&gt;Ensure the application you are authenticating to (1) has an Application ID Url configured within the App Registration blade of the application.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2023/03/1.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2023/03/1-1024x548.png&quot; alt=&quot;&quot; class=&quot;wp-image-6857&quot; /&gt;&lt;/figure&gt;


&lt;p&gt;If this is not configured, make sure to add it.&lt;/p&gt;


&lt;h2&gt;Step 2: Create an App Role&lt;/h2&gt;


&lt;p&gt;An &apos;App Role&apos; needs to be defined to authenticate your application. For this, go to the &apos;App Role&apos; blade for the App Registration you are authenticating to (1).&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2023/03/2.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2023/03/2-1024x449.png&quot; alt=&quot;&quot; class=&quot;wp-image-6859&quot; /&gt;&lt;/figure&gt;


&lt;p&gt;If an App Role does not exist, create a new one and fill in the required properties. Make sure also to select Applications in the allowed &quot;member types&quot; and enable it. Adding these roles makes sure that the roles are added to the token of the application.&lt;/p&gt;


&lt;figure class=&quot;wp-block-table&quot;&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Field&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Display Name&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Display the name for the app role that appears in the admin consent and app assignment experiences. This value may contain spaces.&lt;/td&gt;
&lt;td&gt;Survey Writer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Allowed member types&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Specifies whether this app role can be assigned to users, applications, or both.&lt;/td&gt;
&lt;td&gt;Users/Groups&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Value&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Specifying the roles&apos; value claim that the application should expect in the token. The value should match the string referenced in the application&apos;s code, which can&apos;t contain spaces.&lt;/td&gt;
&lt;td&gt;Survey. Create&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;A more detailed description of the app role displayed during admin app assignment and consent experiences.&lt;/td&gt;
&lt;td&gt;Writers can create surveys.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Do you want to enable this app role?&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Specifies whether the app role is enabled. To delete an app role, deselect this checkbox and apply the change before attempting the delete operation.&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Checked&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/figure&gt;


&lt;h2&gt;Step 3: Add application API Permission&lt;/h2&gt;


&lt;p&gt;On the &apos;API Permission&apos; blade of the application you are authenticating with (2), the required permissions for the application need to be configured. In the blade, click &apos;Add permission.&apos;&lt;/p&gt;


&lt;p&gt;Then go to the tab &quot;APIs&quot; my organization uses and search for your App Registration. You should be able to see the name within the list.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2023/03/3.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2023/03/3-1024x517.png&quot; alt=&quot;&quot; class=&quot;wp-image-6861&quot; /&gt;&lt;/figure&gt;


&lt;p&gt;Click on the application. On the next screen, you should be able to see the roles that you can choose. Select the permissions that are required and click on &quot;Add Permissions.&quot;&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2023/03/5.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2023/03/5-921x1024.png&quot; alt=&quot;&quot; class=&quot;wp-image-6863&quot; /&gt;&lt;/figure&gt;


&lt;h2&gt;Step 4: Admin Consent&lt;/h2&gt;


&lt;p&gt;These types of app roles require an &apos;Admin Consent.&apos; After adding the permission, you will be returned to the API permissions blade. In this blade, click on &apos;Grant admin consent for.&apos;&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2023/03/6.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2023/03/6-1024x452.png&quot; alt=&quot;&quot; class=&quot;wp-image-6865&quot; /&gt;&lt;/figure&gt;</content><author><name>Maik van der Gaag</name></author><category term="Azure" /><summary type="html">Azure App Registrations are a powerful tool for managing resource access and integrating applications with Microsoft&apos;s cloud services. While these registrations are typically used to grant applications access to other Azure resources, they can also be exposed as APIs, allowing external applications to interact with the registered application&apos;s resources securely.</summary></entry><entry><title type="html">Centrally manage your App Configurations</title><link href="http://localhost:4000/2022/12/centrally-manage-your-app-configurations/" rel="alternate" type="text/html" title="Centrally manage your App Configurations" /><published>2022-12-24T11:00:00+01:00</published><updated>2022-12-24T11:00:00+01:00</updated><id>http://localhost:4000/2022/12/centrally-manage-your-app-configurations</id><content type="html" xml:base="http://localhost:4000/2022/12/centrally-manage-your-app-configurations/">&lt;p&gt;The application landscape in Azure has grown significantly in recent years, with a wide range of tools and services available to help businesses build, deploy, and manage their applications in the cloud. From infrastructure as a service (IaaS) offerings like virtual machines and storage to the platform as a service (PaaS) offerings like Azure App Service and Azure Functions, Azure provides a comprehensive set of tools and services to meet the needs of businesses of all sizes.&lt;/p&gt;


&lt;p&gt;This also has an impact on the application landscape of businesses within Azure. As Azure also evolves, the applications/services that are used evolve. This is not always going in a correct manner where there is time to remove technical debt. As the landscape expands, new services are created, and configurations are added. &lt;/p&gt;


&lt;p&gt;This also surfaces a problem: when a configuration needs to be changed, this must be done on multiple locations, and you are bound to forget one.&lt;/p&gt;


&lt;h2&gt;Azure App Configuration&lt;/h2&gt;


&lt;p&gt;This is where Azure App Configuration comes in. &lt;a href=&quot;https://learn.microsoft.com/azure/azure-app-configuration/overview?WT.mc_id=AZ-MVP-5004255&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Azure App Configuration&lt;/a&gt; is a fully managed service that lets you centralize your application&apos;s configuration and feature management. It helps to store and manage configuration data and feature flags in a centralized location, which multiple applications and environments can access.&lt;/p&gt;


&lt;p&gt;One of the key benefits of using Azure App Configuration is that it allows you to manage the configuration of your applications in a consistent and organized manner. Instead of hardcoding configuration values into your application&apos;s codebase, you can store them in Azure App Configuration and retrieve them at runtime. This makes it easier to manage and update your application&apos;s configuration without redeploying your code. &lt;/p&gt;


&lt;p&gt;App Configuration is already a pervasive solution that (at the time of writing this article) has the following capabilities:&lt;/p&gt;


&lt;ul&gt;&lt;/p&gt;
&lt;li&gt;Automatic refresh without restarting an application&lt;/li&gt;


&lt;li&gt;Data encryption (transit/rest)&lt;/li&gt;


&lt;li&gt;Point-in-time snapshots&lt;/li&gt;


&lt;li&gt;Configuration comparison&lt;/li&gt;


&lt;li&gt;Feature Management&lt;/li&gt;


&lt;li&gt;Import / Export&lt;/li&gt;


&lt;li&gt;Geo-Replication (preview)&lt;/li&gt;


&lt;li&gt;Soft Delete&lt;/li&gt;


&lt;li&gt;AAD authentication&lt;/li&gt;


&lt;li&gt;Private Endpoint support&lt;/li&gt;
&lt;p&gt;&lt;/ul&gt;


&lt;p&gt;App Configuration can be used within many frameworks by using a specific client or provider or by using the Rest API:&lt;/p&gt;


&lt;ul&gt;&lt;/p&gt;
&lt;li&gt;.Net Core&lt;/li&gt;


&lt;li&gt;ASP.Net Core&lt;/li&gt;


&lt;li&gt;.Net Framework&lt;/li&gt;


&lt;li&gt;Java Spring&lt;/li&gt;


&lt;li&gt;Javascript&lt;/li&gt;


&lt;li&gt;Python&lt;/li&gt;
&lt;p&gt;&lt;/ul&gt;


&lt;p&gt;When you would like to use it in, for example, PowerShell, you could leverage the API.&lt;/p&gt;


&lt;h2&gt;KeyVault integration&lt;/h2&gt;


&lt;p&gt;As the feature list above isn&apos;t already enough, Azure App Configuration also has KeyVault integration. With the KeyVault integration, you can add configurations referencing a KeyVault secret. Azure App Configuration will redirect you (your principal with a correct token) to retrieve the value from the KeyVault without noticing anything.&lt;/p&gt;


&lt;h2&gt;Getting Started&lt;/h2&gt;


&lt;p&gt;Of course, you can get started by using the Azure Portal, PowerShell, or the CLI, but let&apos;s check if we can create the service using Bicep.&lt;/p&gt;


&lt;h3&gt;Bicep&lt;/h3&gt;


&lt;p&gt;The bicep for setting up Azure App Configuration is very easy. Let&apos;s take a look at the example below.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;resource configStore &apos;Microsoft.AppConfiguration/configurationStores@2021-10-01-preview&apos; = {
    name: &apos;azappconfiguration-${name}&apos;
    location: location
    sku: {
        name: &apos;standard&apos;
    }
    properties:{
        disableLocalAuth: true
        enablePurgeProtection: true
        softDeleteRetentionInDays:7
    }
}&lt;/pre&gt;


&lt;p&gt;The code snippet creates a configuration store with the &apos;standard&apos; SKU, enables purge protection, and sets the soft delete retention to 7 days. Next to that, it also disables the local authentication, meaning that you cannot authenticate to the configuration store by using a key but are required to use a token to authenticate.&lt;/p&gt;


&lt;p&gt;Configurations, secret references, and features can also be added by using Bicep. For this, I created a handy module.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;param configStoreName string

param configItems array

resource configStore &apos;Microsoft.AppConfiguration/configurationStores@2021-10-01-preview&apos; existing = {
  name: configStoreName
}

resource configStoreKeyValue &apos;Microsoft.AppConfiguration/configurationStores/keyValues@2021-10-01-preview&apos; = [for item in configItems:  {
  parent: configStore
  name: (!item.featureFlag) ? item.name : &apos;.appconfig.featureflag~2F${item.name}&apos;
  properties: {
    value: (!item.featureFlag) ? item.value : &apos;{&quot;id&quot;: &quot;${item.name}&quot;, &quot;description&quot;: &quot;&quot;, &quot;enabled&quot;: false, &quot;conditions&quot;: {&quot;client_filters&quot;:[]}}&apos;
    tags: item.tags
    contentType:item.contentType
  }
}]&lt;/pre&gt;


&lt;p&gt;The item will be configured correctly based on the array supplied as a parameter. A sample array for the configuration could look like the snippet below.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;[
    {
        name: &apos;Bicep:Config:Value&apos;
        value: &apos;Test from Bicep&apos;
        contenttype: &apos;&apos;
        featureFlag: false
        tags: {
            Bicep: &apos;Deployed&apos;
        }
    }
        {
        name: &apos;Bicep:Secret:KeyVault&apos;
        value: &apos;https://azkv-appconfiguration123.vault.azure.net/secrets/bicep-configuration-secret&apos;
        contenttype: &apos;application/vnd.microsoft.appconfig.keyvaultref+json;charset=utf-8&apos;
        featureFlag: false
        tags: {
            Bicep: &apos;Deployed&apos;
        }
    }
    {
        name: &apos;bicep-featureflag&apos;
        value: &apos;&apos;
        contenttype: &apos;application/vnd.microsoft.appconfig.ff+json;charset=utf-8&apos;
        featureFlag: true
        tags: {
            Bicep: &apos;Deployed&apos;
        }
    }
]&lt;/pre&gt;


&lt;h2&gt;Getting it in Code&lt;/h2&gt;


&lt;p&gt;Adding Azure App Configuration in code is very easy. This article will look into C# and .Net Core 6. Make sure you add the following prerequisites as NuGet packages to your project.&lt;/p&gt;


&lt;ul&gt;&lt;/p&gt;
&lt;li&gt;&lt;strong&gt;Microsoft.Extensions.Configuration.AzureAppConfiguration&lt;/strong&gt; version 4.1.0 or later&lt;/li&gt;


&lt;li&gt;&lt;strong&gt;Microsoft.Azure.Functions.Extensions&lt;/strong&gt; version 1.10 or later: This one is needed to incorporate the Azure Functions configurations.&lt;/li&gt;
&lt;p&gt;&lt;/ul&gt;


&lt;p&gt;The next step is to add the following code to your application startup.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;var endpoint = app.Configuration[&quot;AppConfig:Endpoint&quot;];
builder.Configuration.AddAzureAppConfiguration(options =&gt; {
    options.Connect(new Uri(endpoint), new DefaultAzureCredential())
            .ConfigureKeyVault(kv =&gt; {
                kv.SetCredential(new DefaultAzureCredential());
            })
	     .Select(&quot;Demo:*&quot;, LabelFilter.Null)
            .ConfigureRefresh(refreshOptions =&gt;
                refreshOptions.Register(&quot;Demo:Config:Sentinel&quot;, refreshAll: true));
});&lt;/pre&gt;


&lt;p&gt;On line 1 of the snippet, we retrieve the configuration store&apos;s endpoint and then aff Azure App Configuration to the application.  By using &apos;DefaultAzureCredential&apos;, we make sure that we connect to the configuration store by the managed identity of the service.  On line 4, we then set up the connection to the KeyVault to retrieve values and specify that for this, we also want to use the managed identity.&lt;/p&gt;


&lt;p&gt;With the &apos;Select&apos; we start specifying which configurations we want. In this example, we want all configurations that start with &apos;Demo:&apos; and do not have a label. Using the labels, we could have specified an environment, for example. &lt;/p&gt;


&lt;p&gt;On line 9, we then configure the refresh options to ensure that the application configurations are automatically refreshed when we update the sentinel key &quot;Demo:Config:Sentinel&quot; in the configuration store.&lt;/p&gt;


&lt;p&gt;When you would also like to make use of feature management, you would also add the following lines&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;options.UseFeatureFlags(featureFlagOptions =&gt; {
        featureFlagOptions.Select(&quot;DemoApp-*&quot;, app.Environment.EnvironmentName);
        featureFlagOptions.CacheExpirationInterval = TimeSpan.FromSeconds(30);
    });&lt;/pre&gt;


&lt;h2&gt;Using the configuration&lt;/h2&gt;


&lt;p&gt;Using the configuration is now very easy the below snippet is a function that retrieves a configuration value.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;public class DummyFunction
    {
        private readonly IConfiguration _configuration;

        public DummyFunction(IConfiguration configuration) {
            _configuration = configuration;
        }

        [FunctionName(&quot;DummyFunction&quot;)]
        public async Task&amp;lt;IActionResult&gt; Run(
            [HttpTrigger(AuthorizationLevel.Function, &quot;get&quot;, &quot;post&quot;, Route = null)] HttpRequest req,
            ILogger log)
        {
            log.LogInformation(&quot;C# HTTP trigger function processed a request.&quot;);

            string configKey = &quot;DemoFunc:Message&quot;;
            string message = _configuration[configKey];
            
            log.LogInformation($&quot;Found the config in Azure App Configuration {message}&quot;);

            string requestBody = await new StreamReader(req.Body).ReadToEndAsync();

            string responseMessage = string.IsNullOrEmpty(message)
                ? &quot;There is no configuration value with the key &apos;Demo:FunctionApp:Message&apos; in Azure App Configuration&quot;
                : message;

            return new OkObjectResult(responseMessage);
        }
    }&lt;/pre&gt;


&lt;p&gt;Also, for features, this more or less looks the same. The only difference here is that we use a so-called FeatureManager. For this snippet, we removed some lines of code for simplicity.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;public class WCController : ControllerBase {
       
        private readonly ILogger&amp;lt;WCController&gt; _logger;

        private readonly IFeatureManager _featureManager;

        public WCController(ILogger&amp;lt;WCController&gt; logger, IFeatureManager manager) {
            _logger = logger;
            _featureManager = manager;
        }

        [HttpGet(Name = &quot;GetTeams&quot;)]
        public IEnumerable&amp;lt;Teams&gt; Get() {

            IEnumerable&amp;lt;Teams&gt; retVal = new List&amp;lt;Teams&gt;();

            if (_featureManager.IsEnabledAsync(&quot;DemoApi-Points&quot;).Result) {
               
            } else {
               
            }

            return retVal;
        }
    }&lt;/pre&gt;


&lt;p&gt;When using features, you also have some other nice options as:&lt;/p&gt;


&lt;ul&gt;&lt;/p&gt;
&lt;li&gt;Feature Gates: The feature gate attributes make sure something is only available when the specified feature is activated.&lt;/li&gt;
&lt;p&gt;&lt;/ul&gt;


&lt;pre class=&quot;highlight&quot;&gt;    [FeatureGate(&quot;DemoApi-WC&quot;)]&lt;/pre&gt;


&lt;ul&gt;&lt;/p&gt;
&lt;li&gt;Feature Tag: The &amp;lt;feature&amp;gt;&amp;nbsp;tag ensures that items are shown only when the&amp;nbsp;feature flag is enabled.&lt;/li&gt;
&lt;p&gt;&lt;/ul&gt;


&lt;pre class=&quot;highlight&quot;&gt;    &amp;lt;feature name=&quot;DemoApp-Beta&quot;&gt;
        &amp;lt;p&gt;Beta feature is enabled!&amp;lt;/p&gt;
    &amp;lt;/feature&gt;&lt;/pre&gt;


&lt;h2&gt;Azure DevOps&lt;/h2&gt;


&lt;p&gt;In a real-life scenario, configurations are mostly managed and deployed from Azure DevOps. Azure App Configuration can also help in these situations because Azure DevOps has a task that retrieves configuration values and converts them to variables.&lt;/p&gt;


&lt;p&gt;Take a look at the pipeline in the below snippet. In the first steps, the configuration is retrieved and later displayed with a PowerShell task. Good to mention here as well is that KeyVault references are also retrieved and specified as secure variables.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;trigger:
- main

pool:
  vmImage: ubuntu-latest

steps:

- task: AzureAppConfiguration@5
  displayName: Get Azure App Configurations
  inputs:
    azureSubscription: &apos;sub-sub-sub&apos;
    AppConfigurationEndpoint: &apos;https://azapp-sub.azconfig.io&apos;
    KeyFilter: &apos;DevOps:*&apos;
- task: PowerShell@2
  displayName: Display values from App Configuration
  inputs:
    targetType: &apos;inline&apos;
    script: |
      Write-Host &quot;Regular value: $(DevOps:DemoValue)&quot;
      Write-Host &quot;Secret value: $(DevOps:Secret:DevOpsSecret)&quot;
&lt;/pre&gt;


&lt;h2&gt;My Take away’s&lt;/h2&gt;


&lt;ul&gt;&lt;/p&gt;
&lt;li&gt;&lt;strong&gt;Issues in the configuration can cause the application to break on start-up&lt;/strong&gt;: As configurations are loaded at the application&apos;s startup, problems with the configuration or lack of permissions can break the complete application.&lt;/li&gt;


&lt;li&gt;&lt;strong&gt;Do not forget to authorize the application in the Azure Key Vault&lt;/strong&gt;: When working with KeyVault references, ensure that the identity used has the appropriate permissions on Azure App Configuration and the KeyVault.&lt;/li&gt;


&lt;li&gt;&lt;strong&gt;Use labels to sort/group configurations&lt;/strong&gt;: Labels add the ability to have different configurations for different scenarios like environments.&lt;/li&gt;


&lt;li&gt;&lt;strong&gt;RBAC permissions can take time before they are in place&lt;/strong&gt;.&lt;/li&gt;


&lt;li&gt;&lt;strong&gt;Case Sensitive:&lt;/strong&gt; All configurations added are case sensitive.&lt;/li&gt;



&lt;p&gt;&lt;/ul&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;


&lt;p&gt;In conclusion, Azure App Configuration is a powerful service for managing your applications&apos; configuration and feature management. Centralizing your configuration data and providing feature management capabilities helps you build more flexible and maintainable applications.&lt;/p&gt;


&lt;p&gt;If you want to see the code in more detail and look at different examples, go check out my &lt;a href=&quot;https://github.com/maikvandergaag/msft-appconfiguration&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;GitHub repo&lt;/a&gt;.&lt;/p&gt;


&lt;h2&gt;Chrismas Present&lt;/h2&gt;


&lt;p&gt;As a small present for Christmas, I also wanted to share an option we use very often. That option is using Azure App Configuration from PowerShell. &lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;Function Get-AzAppConfigurationKey {
    Param(
        [parameter(Mandatory = $true)][string]$AppConfiguration,
        [parameter(Mandatory = $true)][string]$Key
    )</content><author><name>Maik van der Gaag</name></author><category term="Azure" /><category term="Azure" /><category term="Configuration" /><summary type="html">The application landscape in Azure has grown significantly in recent years, with a wide range of tools and services available to help businesses build, deploy, and manage their applications in the cloud. From infrastructure as a service (IaaS) offerings like virtual machines and storage to the platform as a service (PaaS) offerings like Azure App Service and Azure Functions, Azure provides a comprehensive set of tools and services to meet the needs of businesses of all sizes.</summary></entry><entry><title type="html">Shift Left Security with Microsoft Security DevOps (MSDO)</title><link href="http://localhost:4000/2022/10/shift-left-security-with-microsoft-security-devops-msdo/" rel="alternate" type="text/html" title="Shift Left Security with Microsoft Security DevOps (MSDO)" /><published>2022-10-20T16:15:31+02:00</published><updated>2022-10-20T16:15:31+02:00</updated><id>http://localhost:4000/2022/10/shift-left-security-with-microsoft-security-devops-msdo</id><content type="html" xml:base="http://localhost:4000/2022/10/shift-left-security-with-microsoft-security-devops-msdo/">&lt;p&gt;With the new capabilities released add Ignite, you are now even more capable of shifting security checks further to the left. In this &lt;a href=&quot;https://msftplayground.com/2022/10/microsoft-defender-for-devops/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;article&lt;/a&gt;, I explain how to get started by adding DevOps and GitHub to Defender for Cloud, which does the first part. In this article, we will look more into integrating security right into DevOps pipelines.&lt;/p&gt;


&lt;p&gt;To integrate the security checks in your pipeline and, Ideally, also in your pull request annotations, some prerequisites are needed that are by default not in Azure DevOps:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;The Microsoft Security DevOps extensions: This is an Azure DevOps extension required to do a security scan within Azure DevOps.&lt;/li&gt;
&lt;li&gt;The SARIF SAST Scans Tab extensions: This Azure DevOps extension adds a Scan tab to the Azure DevOps pipeline that shows scan results.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;These extensions can be installed from the Visual Studio Marketplace:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ms-securitydevops.microsoft-security-devops-azdevops&quot;&gt;Microsoft Security DevOps - Visual Studio Marketplace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=sariftools.scans&amp;amp;targetId=8e02e9e3-062e-46a7-8558-c30016c43306&amp;amp;utm_source=vstsproduct&amp;amp;utm_medium=ExtHubManageList&quot;&gt;SARIF SAST Scans Tab - Visual Studio Marketplace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;The Microsoft Security DevOps Extension&lt;/h2&gt;


&lt;p&gt;The Microsoft Security DevOps extension is a wrapper around the &lt;a href=&quot;https://www.nuget.org/packages/Microsoft.Security.DevOps.Cli&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Microsoft.Security.DevOps.Cli&lt;/a&gt;. The CLI is the Microsoft Security DevOps (MSDO), a command-line application that integrates static analysis tools into the development cycle. &lt;/p&gt;


&lt;p&gt;The tool installs and configures static analysis tools and saves the results in a format called SARIF. In the table below, the tools it uses are listed.&lt;/p&gt;


&lt;figure class=&quot;wp-block-table&quot;&gt;
&lt;table /&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/PyCQA/bandit&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Bandit&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/Microsoft/binskim&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;BinSkim&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;binary - Windows, ELF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/eslint/eslint&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;ESlint&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;JavaScript&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/Azure/template-analyzer&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Template Analyzer&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Infrastructure-as-code (IaC), ARM templates&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/accurics/terrascan&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Terrascan&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Infrastructure-as-code (IaC), Terraform (HCL2), Kubernetes (JSON/YAML), Helm v3, Kustomize, Dockerfiles&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/aquasecurity/trivy&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Trivy&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;container images, file systems, and git repositories&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/figure&gt;


&lt;h2&gt;Getting Started&lt;/h2&gt;


&lt;p&gt;First, create a new Pipeline in Azure DevOps and make sure that the pipeline supports &quot;.Net 3.1&quot; and &quot;.Net 6.0&quot;. These are required to run the Security DevOps Extension, which can be done by adding the tasks below to the pipeline.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;- task: UseDotNet@2
  displayName: &apos;Use dotnet 3.1&apos;
  inputs:
    version: 3.1.x
- task: UseDotNet@2
  displayName: &apos;Use dotnet 6.0&apos;
  inputs:
    version: 6.0.x&lt;/pre&gt;


&lt;p&gt;These actions must be run before the extension itself to ensure that all components on the build agent are configured, and the Security for DevOps scan can run successfully.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;- task: MicrosoftSecurityDevOps@1
  displayName: &apos;Run Microsoft Security DevOps&apos;&lt;/pre&gt;


&lt;p&gt;The above task executes the scanner and publishes the result by default in the &quot;CodeAnalysisLogs&quot; artifact. To display the scan results, this artifact needs to be published. When published, the scan results will appear in the pipeline&apos;s &quot;Scans&quot; tab. To publish the results, add the below Publish task.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;- task: PublishBuildArtifacts@1
  condition: always()
  inputs:
    PathtoPublish: &apos;$(Build.ArtifactStagingDirectory)&apos;
    ArtifactName: &apos;CodeAnalysisLogs&apos;
    publishLocation: &apos;Container&apos;&lt;/pre&gt;


&lt;p&gt;Putting all of this together ensures that the results are published and viewable in the &quot;Scans&quot; tab when you run the pipeline. The example below shows the result of a scan on one of my repos that contains some bicep files.&lt;/p&gt;




&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/10/image.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/10/image-1024x549.png&quot; alt=&quot;&quot; class=&quot;wp-image-6737&quot; /&gt;&lt;/figure&gt;


&lt;p&gt;The complete pipeline YAML file looks like below. Some parts are left out for simplicity.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;trigger:
- main

pool:
  vmImage: windows-latest

variables:
  - name: system.debug
    value: true

steps:
- task: UseDotNet@2
  displayName: &apos;Use dotnet 3.1&apos;
  inputs:
    version: 3.1.x
- task: UseDotNet@2
  displayName: &apos;Use dotnet 6.0&apos;
  inputs:
    version: 6.0.x
- task: MicrosoftSecurityDevOps@1
  displayName: &apos;Run Microsoft Security DevOps&apos;
- task: PublishBuildArtifacts@1
  condition: always()
  inputs:
    PathtoPublish: &apos;$(Build.ArtifactStagingDirectory)&apos;
    ArtifactName: &apos;CodeAnalysisLogs&apos;
    publishLocation: &apos;Container&apos;&lt;/pre&gt;


&lt;h2&gt;Information&lt;/h2&gt;


&lt;p&gt;If you want to learn more about Microsoft Defender for Cloud or especially Defender for DevOps, check out the following resources:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.microsoftpressstore.com/promotions/yuri-diogenes-video-142436&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Look Inside: Microsoft Defender for Cloud | Microsoft Press Store&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/azure/defender-for-cloud/?WT.mc_id=AZ-MVP-5004255&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Microsoft Defender for Cloud documentation | Microsoft Learn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-devops-introduction&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Microsoft Defender for DevOps - the benefits and features | Microsoft Learn&lt;/a&gt;&lt;/li&gt;</content><author><name>Maik van der Gaag</name></author><category term="Azure" /><category term="Azure DevOps" /><category term="Azure DevOps" /><category term="Defender" /><category term="Security" /><category term="Shift Left" /><summary type="html">With the new capabilities released add Ignite, you are now even more capable of shifting security checks further to the left. In this article, I explain how to get started by adding DevOps and GitHub to Defender for Cloud, which does the first part. In this article, we will look more into integrating security right into DevOps pipelines.</summary></entry><entry><title type="html">Microsoft Defender for DevOps</title><link href="http://localhost:4000/2022/10/microsoft-defender-for-devops/" rel="alternate" type="text/html" title="Microsoft Defender for DevOps" /><published>2022-10-20T15:50:51+02:00</published><updated>2022-10-20T15:50:51+02:00</updated><id>http://localhost:4000/2022/10/microsoft-defender-for-devops</id><content type="html" xml:base="http://localhost:4000/2022/10/microsoft-defender-for-devops/">&lt;p&gt;During Ignite 2022, Microsoft released Microsoft Defender for DevOps. With Microsoft Defender for DevOps, you can discover, monitor, and detect threats in your source code management systems and&lt;br /&gt;source code. &lt;/p&gt;


&lt;p&gt;A connection to the source management system is required to get these insights. With this connection, you allow Defender for Cloud to discover the resources in, for example, your Azure DevOps organization or your GitHub Repositories.&lt;/p&gt;


&lt;h2&gt;Connecting Azure DevOps&lt;/h2&gt;


&lt;p&gt;In the following steps, we will go over the procedure to connect Defender for DevOps to your Azure DevOps organization:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;Log in to the Azure Portal and go to &quot;Defender for Cloud.&quot;&lt;/li&gt;
&lt;li&gt;In the left menu, select &quot;Environment Settings.&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/10/image-1.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/10/image-1-1024x379.png&quot; alt=&quot;Defender for Cloud Environment settings&quot; class=&quot;wp-image-6749&quot; /&gt;&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;In the Environment Settings blade, click on &quot;Add environment&quot; and &quot;Azure DevOps.&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/10/image-2.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/10/image-2-1024x403.png&quot; alt=&quot;Azure DevOps Connector detauls&quot; class=&quot;wp-image-6753&quot; /&gt;&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;Defender for Cloud needs a resource created in Azure for the connection to work. That is why the connection steps ask you for a resource group and a name. Fill in a name and select or create a resource group.&lt;/li&gt;
&lt;li&gt;In the next step, select the right plan. For now, there is just one option called &quot;DevOps.&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/10/image-3.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/10/image-3-1024x236.png&quot; alt=&quot;&quot; class=&quot;wp-image-6755&quot; /&gt;&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;When the plan is selected, the authorization to Azure DevOps can be configured. Log in to your account for Azure DevOps and select the organization and projects for which you need to configure Defender for DevOps.&lt;/li&gt;
&lt;/ul&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/10/image-4.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/10/image-4-1024x870.png&quot; alt=&quot;&quot; class=&quot;wp-image-6757&quot; /&gt;&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;The last step is to create the connection. Click on create and wait until the link is deployed and configured.&lt;/li&gt;
&lt;/ul&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/10/image-5.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/10/image-5-1024x543.png&quot; alt=&quot;&quot; class=&quot;wp-image-6759&quot; /&gt;&lt;/figure&gt;


&lt;p&gt;After a while will start to pop up in Defender for DevOps. With this, you will be able to mitigate vulnerabilities in Azure DevOps.&lt;/p&gt;


&lt;h2&gt;Connecting GitHub&lt;/h2&gt;


&lt;p&gt;Connecting GitHub is almost the same as connecting Azure DevOps except for the connection and authorization. Let&apos;s discover this by following the below steps:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;Start from &quot;Defender for Cloud.&quot;&lt;/li&gt;
&lt;li&gt;In the left menu, select &quot;Environment Settings.&quot;&lt;/li&gt;
&lt;li&gt;On the &quot;Add Environment&quot; step, select &quot;GitHub.&quot;&lt;/li&gt;
&lt;li&gt;The connection details and plans blade are identical to the Azure DevOps connection. Fill in the correct info and proceed to the Authorization blade.&lt;/li&gt;
&lt;li&gt;In the &quot;Authorize connection&quot; blade, authorize the connection in two steps. The first step is to supply the credentials and the second step is to install the Defender for DevOps app on the repositories of your choice.&lt;/li&gt;
&lt;/ul&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/10/image-6.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/10/image-6-1024x795.png&quot; alt=&quot;&quot; class=&quot;wp-image-6761&quot; /&gt;&lt;/figure&gt;


&lt;p&gt;Just as with the DevOps connection for Azure DevOps, it will take a while before the information is displayed in the Defender for DevOps tab.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/10/image-7.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/10/image-7-1024x508.png&quot; alt=&quot;&quot; class=&quot;wp-image-6763&quot; /&gt;&lt;/figure&gt;


&lt;h2&gt;Azure Resources&lt;/h2&gt;


&lt;p&gt;You can check the resource group for the created resources/connections if interested. To see the resources check the box &quot;Show hidden types&quot; to make the connections visible.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-large is-resized&quot;&gt;&lt;a href=&quot;/assets/archive/2022/10/image-8.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/10/image-8-1024x413.png&quot; alt=&quot;&quot; class=&quot;wp-image-6765&quot; width=&quot;840&quot; height=&quot;338&quot; /&gt;&lt;/figure&gt;


&lt;h2&gt;Information&lt;/h2&gt;


&lt;p&gt;If you want to learn more about Microsoft Defender for Cloud or especially Defender for DevOps, check out the following resources:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.microsoftpressstore.com/promotions/yuri-diogenes-video-142436&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Look Inside: Microsoft Defender for Cloud | Microsoft Press Store&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/azure/defender-for-cloud/?WT.mc_id=AZ-MVP-5004255&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Microsoft Defender for Cloud documentation | Microsoft Learn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-devops-introduction&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Microsoft Defender for DevOps - the benefits and features | Microsoft Learn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Maik van der Gaag</name></author><category term="Azure" /><category term="Azure" /><category term="Azure DevOps" /><category term="Defender" /><category term="DevOps" /><summary type="html">During Ignite 2022, Microsoft released Microsoft Defender for DevOps. With Microsoft Defender for DevOps, you can discover, monitor, and detect threats in your source code management systems andsource code.</summary></entry><entry><title type="html">Default Role Based Access Control on newly created resource groups</title><link href="http://localhost:4000/2022/08/default-role-based-access-control-on-newly-created-resource-groups/" rel="alternate" type="text/html" title="Default Role Based Access Control on newly created resource groups" /><published>2022-08-12T09:22:05+02:00</published><updated>2022-08-12T09:22:05+02:00</updated><id>http://localhost:4000/2022/08/default-role-based-access-control-on-newly-created-resource-groups</id><content type="html" xml:base="http://localhost:4000/2022/08/default-role-based-access-control-on-newly-created-resource-groups/">&lt;p&gt;Within our company, we have a sponsorship subscription we use for developing / testing purposes. As we heavily use this subscription, we often come into problems with access rights depending on the type of resource group.&lt;/p&gt;


&lt;p&gt;In a larger environment, we would solve this by creating multiple subscriptions, but as we do not have multiple sponsorship subscriptions, we came up with another idea.&lt;/p&gt;


&lt;p&gt;We categorize resource groups by using tags and came up with the idea to set up access rights on the resource groups based on the tags that are supplied on newly created resource groups. To get this operational, a colleague and I thought out a new custom policy that he created that I am sharing with the community.&lt;/p&gt;


&lt;p&gt;For this policy, we use the policy effect &apos;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/governance/policy/concepts/effects#deployifnotexists?WT.mc_id=AZ-MVP-5004255&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;deployIfnotexists&lt;/a&gt;&apos;. By using this effect, we have the option to execute a deployment when a new resource group is created by using the below policy rule.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;            &quot;if&quot;: {
                &quot;allOf&quot;: [
                    {
                        &quot;field&quot;: &quot;type&quot;,
                        &quot;equals&quot;: &quot;Microsoft.Resources/subscriptions/resourceGroups&quot;
                    },
                    {
                        &quot;field&quot;: &quot;[concat(&apos;tags[&apos;, parameters(&apos;tagName&apos;), &apos;]&apos;)]&quot;,
                        &quot;equals&quot;: &quot;[parameters(&apos;tagValue&apos;)]&quot;
                    }
                ]
            }&lt;/pre&gt;


&lt;p&gt;This rule checks if the type of the resource is a resource group and if it contains a tag with a specific value. The tag and its value it needs to check up on are specified when assigning the policy to a specific scope.&lt;/p&gt;


&lt;p&gt;The &apos;then&apos; of the rule will then execute a deployment, which is just a general RBAC deployment via ARM.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;&quot;then&quot;: {
                &quot;effect&quot;: &quot;deployIfNotExists&quot;,
                &quot;details&quot;: {
                    &quot;EvaluationDelay&quot;: &quot;AfterProvisioningSuccess&quot;,
                    &quot;roleDefinitionIds&quot;: [
                        &quot;/providers/microsoft.authorization/roleDefinitions/8e3af657-a8ff-443c-a75c-2fe8c4bcb635&quot;
                    ],
                    &quot;type&quot;: &quot;Microsoft.Authorization/roleAssignments&quot;,
                    &quot;existenceCondition&quot;: {
                        &quot;allOf&quot;: [
                            {
                                &quot;field&quot;: &quot;Microsoft.Authorization/roleAssignments/roleDefinitionId&quot;,
                                &quot;equals&quot;: &quot;[concat(&apos;/subscriptions/&apos;,subscription().subscriptionId ,parameters(&apos;roleId&apos;))]&quot;
                            },
                            {
                                &quot;field&quot;: &quot;Microsoft.Authorization/roleAssignments/principalId&quot;,
                                &quot;equals&quot;: &quot;[parameters(&apos;principalId&apos;)]&quot;
                            }
                        ]
                    },
                    &quot;deployment&quot;: {
                        &quot;properties&quot;: {
                            &quot;mode&quot;: &quot;incremental&quot;,
                            &quot;parameters&quot;: {
                                &quot;principalType&quot;: {
                                    &quot;value&quot;: &quot;[parameters(&apos;principalType&apos;)]&quot;
                                },
                                &quot;principalId&quot;: {
                                    &quot;value&quot;: &quot;[parameters(&apos;principalId&apos;)]&quot;
                                },
                                &quot;roleId&quot;: {
                                    &quot;value&quot;: &quot;[parameters(&apos;roleId&apos;)]&quot;
                                }
                            },
                            &quot;template&quot;: {
                                &quot;$schema&quot;: &quot;http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&quot;,
                                &quot;contentVersion&quot;: &quot;1.0.0.0&quot;,
                                &quot;parameters&quot;: {
                                    &quot;principalType&quot;: {
                                        &quot;type&quot;: &quot;string&quot;
                                    },
                                    &quot;principalId&quot;: {
                                        &quot;type&quot;: &quot;string&quot;
                                    },
                                    &quot;roleId&quot;: {
                                        &quot;type&quot;: &quot;string&quot;
                                    }
                                },
                                &quot;variables&quot;: {},
                                &quot;resources&quot;: [
                                    {
                                        &quot;name&quot;: &quot;[guid(resourceGroup().id, deployment().name)]&quot;,
                                        &quot;type&quot;: &quot;Microsoft.Authorization/roleAssignments&quot;,
                                        &quot;apiVersion&quot;: &quot;2020-10-01-preview&quot;,
                                        &quot;properties&quot;: {
                                            &quot;principalId&quot;: &quot;[parameters(&apos;principalId&apos;)]&quot;,
                                            &quot;roleDefinitionId&quot;: &quot;[parameters(&apos;roleId&apos;)]&quot;,
                                            &quot;principalType&quot;: &quot;[parameters(&apos;principalType&apos;)]&quot;
                                        }
                                    }
                                ],
                                &quot;outputs&quot;: {
                                    &quot;policy&quot;: {
                                        &quot;type&quot;: &quot;string&quot;,
                                        &quot;value&quot;: &quot;[concat(&apos;Added RBAC Rights&apos;)]&quot;
                                    }
                                }
                            }
                        }
                    }
                }
            }&lt;/pre&gt;


&lt;p&gt;On the &apos;deployifnotexists&apos;, there is also an &apos;EvaluationDelay&apos; specified. This specifies when the existence of the related resources should be evaluated. The delay is only used for evaluations that are a result of a create or update resource request. So the evaluation is done after the provisioning is succeeded.&lt;/p&gt;


&lt;p&gt;The complete policy definitions then look like this.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;{
    &quot;properties&quot;: {
        &quot;displayName&quot;: &quot;Add access rights based on tags&quot;,
        &quot;policyType&quot;: &quot;Custom&quot;,
        &quot;mode&quot;: &quot;All&quot;,
        &quot;description&quot;: &quot;Policy to add access rights based on tags added to a resource group&quot;,
        &quot;metadata&quot;: {
            &quot;version&quot;: &quot;1.0.0&quot;,
            &quot;category&quot;: &quot;Custom&quot;
        },
        &quot;parameters&quot;: {
            &quot;tagName&quot;: {
                &quot;type&quot;: &quot;String&quot;,
                &quot;metadata&quot;: {
                    &quot;displayName&quot;: &quot;Tag Name&quot;,
                    &quot;description&quot;: &quot;The Tag name to audit against (i.e. Environment CostCenter etc.)&quot;
                },
                &quot;defaultValue&quot;: &quot;Environment&quot;
            },
            &quot;tagValue&quot;: {
                &quot;type&quot;: &quot;String&quot;,
                &quot;metadata&quot;: {
                    &quot;displayName&quot;: &quot;Tag Value&quot;,
                    &quot;description&quot;: &quot;Value of the tag to audit against (i.e. Prod/UAT/TEST 12345 etc.)&quot;
                }
            },
            &quot;roleId&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;metadata&quot;: {
                    &quot;displayName&quot;: &quot;roleId&quot;,
                    &quot;description&quot;: &quot;roleId&quot;,
                    &quot;strongType&quot;: &quot;Microsoft.Authorization/roleDefinitions&quot;
                }
            },
            &quot;principalId&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;metadata&quot;: {
                    &quot;displayName&quot;: &quot;principalId&quot;,
                    &quot;description&quot;: &quot;principalId&quot;
                }
            },
            &quot;principalType&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;metadata&quot;: {
                    &quot;displayName&quot;: &quot;principalType&quot;,
                    &quot;description&quot;: &quot;principalType&quot;
                },
                &quot;allowedValues&quot;: [
                    &quot;Device&quot;,
                    &quot;ForeignGroup&quot;,
                    &quot;Group&quot;,
                    &quot;ServicePrincipal&quot;,
                    &quot;User&quot;
                ]
            }
        },
        &quot;policyRule&quot;: {
            &quot;if&quot;: {
                &quot;allOf&quot;: [
                    {
                        &quot;field&quot;: &quot;type&quot;,
                        &quot;equals&quot;: &quot;Microsoft.Resources/subscriptions/resourceGroups&quot;
                    },
                    {
                        &quot;field&quot;: &quot;[concat(&apos;tags[&apos;, parameters(&apos;tagName&apos;), &apos;]&apos;)]&quot;,
                        &quot;equals&quot;: &quot;[parameters(&apos;tagValue&apos;)]&quot;
                    }
                ]
            },
            &quot;then&quot;: {
                &quot;effect&quot;: &quot;deployIfNotExists&quot;,
                &quot;details&quot;: {
                    &quot;EvaluationDelay&quot;: &quot;AfterProvisioningSuccess&quot;,
                    &quot;roleDefinitionIds&quot;: [
                        &quot;/providers/microsoft.authorization/roleDefinitions/8e3af657-a8ff-443c-a75c-2fe8c4bcb635&quot;
                    ],
                    &quot;type&quot;: &quot;Microsoft.Authorization/roleAssignments&quot;,
                    &quot;existenceCondition&quot;: {
                        &quot;allOf&quot;: [
                            {
                                &quot;field&quot;: &quot;Microsoft.Authorization/roleAssignments/roleDefinitionId&quot;,
                                &quot;equals&quot;: &quot;[concat(&apos;/subscriptions/&apos;,subscription().subscriptionId ,parameters(&apos;roleId&apos;))]&quot;
                            },
                            {
                                &quot;field&quot;: &quot;Microsoft.Authorization/roleAssignments/principalId&quot;,
                                &quot;equals&quot;: &quot;[parameters(&apos;principalId&apos;)]&quot;
                            }
                        ]
                    },
                    &quot;deployment&quot;: {
                        &quot;properties&quot;: {
                            &quot;mode&quot;: &quot;incremental&quot;,
                            &quot;parameters&quot;: {
                                &quot;principalType&quot;: {
                                    &quot;value&quot;: &quot;[parameters(&apos;principalType&apos;)]&quot;
                                },
                                &quot;principalId&quot;: {
                                    &quot;value&quot;: &quot;[parameters(&apos;principalId&apos;)]&quot;
                                },
                                &quot;roleId&quot;: {
                                    &quot;value&quot;: &quot;[parameters(&apos;roleId&apos;)]&quot;
                                }
                            },
                            &quot;template&quot;: {
                                &quot;$schema&quot;: &quot;http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&quot;,
                                &quot;contentVersion&quot;: &quot;1.0.0.0&quot;,
                                &quot;parameters&quot;: {
                                    &quot;principalType&quot;: {
                                        &quot;type&quot;: &quot;string&quot;
                                    },
                                    &quot;principalId&quot;: {
                                        &quot;type&quot;: &quot;string&quot;
                                    },
                                    &quot;roleId&quot;: {
                                        &quot;type&quot;: &quot;string&quot;
                                    }
                                },
                                &quot;variables&quot;: {},
                                &quot;resources&quot;: [
                                    {
                                        &quot;name&quot;: &quot;[guid(resourceGroup().id, deployment().name)]&quot;,
                                        &quot;type&quot;: &quot;Microsoft.Authorization/roleAssignments&quot;,
                                        &quot;apiVersion&quot;: &quot;2020-10-01-preview&quot;,
                                        &quot;properties&quot;: {
                                            &quot;principalId&quot;: &quot;[parameters(&apos;principalId&apos;)]&quot;,
                                            &quot;roleDefinitionId&quot;: &quot;[parameters(&apos;roleId&apos;)]&quot;,
                                            &quot;principalType&quot;: &quot;[parameters(&apos;principalType&apos;)]&quot;
                                        }
                                    }
                                ],
                                &quot;outputs&quot;: {
                                    &quot;policy&quot;: {
                                        &quot;type&quot;: &quot;string&quot;,
                                        &quot;value&quot;: &quot;[concat(&apos;Added RBAC Rights&apos;)]&quot;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}&lt;/pre&gt;




&lt;h2&gt;GitHub&lt;/h2&gt;


&lt;p&gt;Check out GitHub for the script files and the policy also supplied in &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep&amp;amp;WT.mc_id=AZ-MVP-5004255&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Bicep&lt;/a&gt;:&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/maikvandergaag/msft-azureplatform/tree/main/policies/add_access&quot;&gt;https://github.com/maikvandergaag/msft-azureplatform/tree/main/policies/add_access&lt;/a&gt;&lt;/p&gt;</content><author><name>Maik van der Gaag</name></author><category term="Azure" /><category term="Azure" /><category term="Policy" /><category term="RBAC" /><summary type="html">Within our company, we have a sponsorship subscription we use for developing / testing purposes. As we heavily use this subscription, we often come into problems with access rights depending on the type of resource group.</summary></entry><entry><title type="html">Building your Azure Policies (GitHub Actions) - Part 3</title><link href="http://localhost:4000/2022/03/building-your-azure-policies-github-actions-part-3/" rel="alternate" type="text/html" title="Building your Azure Policies (GitHub Actions) - Part 3" /><published>2022-03-17T11:54:00+01:00</published><updated>2022-03-17T11:54:00+01:00</updated><id>http://localhost:4000/2022/03/building-your-azure-policies-github-actions-part-3</id><content type="html" xml:base="http://localhost:4000/2022/03/building-your-azure-policies-github-actions-part-3/">&lt;p&gt;As written in &lt;a href=&quot;https://msftplayground.com/2022/03/building-your-azure-policies-part-1/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;part 1&lt;/a&gt;, policies are used to maintain the state. The Azure portal itself contains a lot of OOTB policies, but you also want to create and deploy your own. In this article, we will go over how to deploy the policy definitions using GitHub Actions.&lt;/p&gt;


&lt;p&gt;In &lt;a href=&quot;https://msftplayground.com/2022/03/building-your-azure-policies-azure-devops-part-2&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;part 2&lt;/a&gt;, we deployed the definitions via Azure DevOps pipelines, and for the Github Actions, we will also use the script file. But in GitHub Actions, there is also another option for managing policy definitions.&lt;/p&gt;


&lt;h2&gt;Prerequisites&lt;/h2&gt;


&lt;ul&gt;
&lt;li&gt;Service principal in Azure Active Directory&lt;/li&gt;
&lt;li&gt;Credentials saved wihtin GitHub&lt;/li&gt;
&lt;li&gt;Access rights in Azure&lt;/li&gt;
&lt;li&gt;GitHub workflow&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;First couple of prerequisites&lt;/h2&gt;


&lt;p&gt;For this test, we will reuse the principal that we created in &lt;a href=&quot;https://msftplayground.com/2022/03/building-your-azure-policies-azure-devops-part-2/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;part 2&lt;/a&gt; of the series. The credentials for this will be saved within a Github Secret.&lt;/p&gt;


&lt;h3&gt;GitHub Secret&lt;/h3&gt;


&lt;p&gt;The information for the authentication is saved within so-called&amp;nbsp;&lt;a href=&quot;https://docs.github.com/en/actions/learn-github-actions/security-hardening-for-github-actions?WT.mc_id=DT-MVP-5004255&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;secrets&lt;/a&gt;&amp;nbsp;that are encrypted within GitHub that are saved on the organization, repository, or repository environment level. The credential information for the authentication against Azure is saved in JSON format.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;{
    &quot;clientId&quot;: &quot;[clientId]&quot;,
    &quot;clientSecret&quot;: &quot;[clientSecret]&quot;,
    &quot;subscriptionId&quot;: &quot;[subscription id]&quot;,
    &quot;tenantId&quot;: &quot;[Azure Active Directory Tenant Id]&quot;
}&lt;/pre&gt;


&lt;p&gt;To save the credential information, you can follow the below steps:&lt;/p&gt;


&lt;ol&gt;
&lt;li&gt;Within the GitHub repository go to settings and then secrets.&lt;/li&gt;
&lt;/ol&gt;


&lt;figure class=&quot;wp-block-image&quot;&gt;&lt;a href=&quot;/assets/archive/2021/06/image-11.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/03/image-11-1024x548.png&quot; alt=&quot;GitHub Secrets&quot; class=&quot;wp-image-6347&quot; /&gt;&lt;/figure&gt;


&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Click on “new repository secret”&lt;/li&gt;
&lt;li&gt;Fill in a name for the secret and use the json object for the value of the secret.&lt;/li&gt;
&lt;/ol&gt;


&lt;figure class=&quot;wp-block-image&quot;&gt;&lt;a href=&quot;/assets/archive/2021/06/image-12.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/03/image-12-1024x337.png&quot; alt=&quot;GitHub Actions Secret&quot; class=&quot;wp-image-6349&quot; /&gt;&lt;/figure&gt;


&lt;h2&gt;Use the Azure steps within GitHub Actions&lt;/h2&gt;


&lt;p&gt;With the credentials saved, we can get started with the workflow. Let&apos;s create a new workflow in the UI and give it a name and file name and remove the information that is not required. To work with Azure, we will use the so-called Azure steps and start with the login step.&lt;/p&gt;


&lt;p&gt;Add the &lt;a href=&quot;https://github.com/marketplace/actions/azure-login&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;&apos;azure/login&apos;&lt;/a&gt; step and connect it to the correct secret. The YAML snippet is below.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;- uses: azure/login@v1
      with:
        creds: $.
        enable-AzPSSession: true &lt;/pre&gt;


&lt;p&gt;&lt;em&gt;&quot;Make sure you add &apos;enable-AzPSSession: true&apos; if you want to make use of Azure PowerShell in the workflow.&quot;&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;In this task, you see the reference to the secret we saved in the previous paragraph.&lt;/p&gt;


&lt;h2&gt;GitHub Actions and Azure PowerShell&lt;/h2&gt;


&lt;p&gt;If you want to start from GitHub and deploy your definitions that haven&apos;t been deployed to Azure yet, you can reuse the script that we used in &lt;a href=&quot;https://msftplayground.com/2022/03/building-your-azure-policies-azure-devops-part-2/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;part 2&lt;/a&gt; and execute it within GitHub actions via the &lt;a href=&quot;https://github.com/marketplace/actions/azure-powershell-action&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Azure PowerShell Action&lt;/a&gt;.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;    - name: Run Azure PowerShell script
      uses: azure/powershell@v1
      with:
        inlineScript: |
          ./scripts/azpolicy.ps1 -Scope &quot;$&quot; -ScopeName &quot;$&quot; -PolicyFolder &quot;$&quot;
        azPSVersion: &quot;latest&quot;&lt;/pre&gt;


&lt;p&gt;We reference the same script file and supply it with the correct arguments in the task. For your reference, the complete Github Actions file would look like below.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;name: Policy - All Policies
on:
  workflow_dispatch:
    inputs:
      remarks:
        description: &apos;Reason for triggering the workflow run&apos;
        required: false
        default: &apos;Updating Azure Policies&apos;

env:
  Folder: &apos;./deploy&apos;
  Scope: &apos;ManagementGroup&apos;
  ScopeName: &apos;324f7296-1869-4489-b11e-912351f38ead&apos;

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    - uses: azure/login@v1
      with:
        creds: $
        enable-AzPSSession: true 
    - name: Run Azure PowerShell script
      uses: azure/powershell@v1
      with:
        inlineScript: |
          ./scripts/azpolicy.ps1 -Scope &quot;$&quot; -ScopeName &quot;$&quot; -PolicyFolder &quot;$&quot;
        azPSVersion: &quot;latest&quot;
&lt;/pre&gt;


&lt;h2&gt;GitHub Actions and Manage Policy Task&lt;/h2&gt;


&lt;p&gt;GitHub actions contain a task (&lt;a href=&quot;https://github.com/marketplace/actions/manage-azure-policy&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Manage Azure Policy&lt;/a&gt;) to manage policy definitions, deploy them to the correct scopes, and manage the assignments. The downside of this task is that it requires the definitions to be deployed on Azure because it references the ids.&lt;/p&gt;


&lt;p&gt;To use this, it is best to export the definitions from Azure and work in the below folder hierarchy.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-full&quot;&gt;&lt;a href=&quot;/assets/archive/2022/03/image-5.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/03/image-5.png&quot; alt=&quot;Policy structure&quot; class=&quot;wp-image-6697&quot; /&gt;&lt;/figure&gt;


&lt;p&gt;The name of the folders refers to the policy names, and the policy.json files contain the information of the policies. These files are the same as shown in part 1, except they have the id, type, and name properties. The task only needs to reference the policy folder, and you are good to go and manage your policy definitions.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;name: Policy - All Policies
on:
  workflow_dispatch:
    inputs:
      remarks:
        description: &apos;Reason for triggering the workflow run&apos;
        required: false
        default: &apos;Updating Azure Policies&apos;

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    - uses: azure/login@v1
      with:
        creds: $
    - name: Create or Update Azure Policies
      uses: azure/manage-azure-policy@v0
      with:      
        paths:  |                  
          policies/**&lt;/pre&gt;


&lt;p&gt;As you can see in the pipeline file, you may have noticed that this pipeline does not reference the management group. This is because the JSON file contains a reference to the id of the existing policy definition, so it knows where it is deployed.&lt;/p&gt;


&lt;p&gt;With this task is, you can also manage your assignments by specifying that in the same folder structure when interested, take a look at the &lt;a href=&quot;https://github.com/marketplace/actions/manage-azure-policy&quot;&gt;page&lt;/a&gt; of the extension.&lt;/p&gt;


&lt;p&gt;Of course, this is not a production-grade solution, but it gives you the highlights on how to manage your policy definitions in code and how to deploy them.&lt;/p&gt;


&lt;h2&gt;To be continued&lt;/h2&gt;


&lt;ul&gt;
&lt;li&gt;Part 1 - &lt;a href=&quot;https://msftplayground.com/2022/03/building-your-azure-policies-part-1/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Building your Azure Policies – Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 2 - &lt;a href=&quot;https://msftplayground.com/2022/03/building-your-azure-policies-azure-devops-part-2/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Building your Azure Policies (Azure DevOps) – Part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Maik van der Gaag</name></author><category term="Azure" /><category term="GitHub Actions" /><category term="Azure" /><category term="GitHub Actions" /><category term="Policy" /><category term="Powershell" /><summary type="html">As written in part 1, policies are used to maintain the state. The Azure portal itself contains a lot of OOTB policies, but you also want to create and deploy your own. In this article, we will go over how to deploy the policy definitions using GitHub Actions.</summary></entry><entry><title type="html">Building your Azure Policies (Azure DevOps) - Part 2</title><link href="http://localhost:4000/2022/03/building-your-azure-policies-azure-devops-part-2/" rel="alternate" type="text/html" title="Building your Azure Policies (Azure DevOps) - Part 2" /><published>2022-03-17T11:26:00+01:00</published><updated>2022-03-17T11:26:00+01:00</updated><id>http://localhost:4000/2022/03/building-your-azure-policies-azure-devops-part-2</id><content type="html" xml:base="http://localhost:4000/2022/03/building-your-azure-policies-azure-devops-part-2/">&lt;p&gt;As written in &lt;a href=&quot;https://msftplayground.com/2022/03/building-your-azure-policies-part-1/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Part 1&lt;/a&gt;, policies are used to maintain the state. The Azure portal itself contains a lot of OOTB policies, but you also want to create and deploy your own. This part will go over how to deploy custom policy definitions using Azure DevOps.&lt;/p&gt;


&lt;h2&gt;Script&lt;/h2&gt;


&lt;p&gt;The script shared in &lt;a href=&quot;https://msftplayground.com/2022/03/building-your-azure-policies-part-1/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;part 1&lt;/a&gt; is adjusted to read out the policy definition files within a directory. This is done because you do not want to deploy just one definition per pipeline. Below the updated PowerShell script is added.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;[CmdletBinding()]
Param(
    [Parameter(Mandatory = $true)]
    [ValidateSet(&apos;Subscription&apos;, &apos;Managementgroup&apos;)]
    [string]$Scope,
    [Parameter(Mandatory = $true)]
    [string]$ScopeName,
    [Parameter(Mandatory = $true)]
    [string]$PolicyFolder,
    [Parameter(Mandatory = $false)]
    [string]$RoleIds
)

$policyFiles = Get-ChildItem -Path $PolicyFolder -Recurse -Filter &quot;*.json&quot;
foreach ($policyFile in $policyFiles) {

    Write-Output &quot;Working on Policy: $($policyFile.Name)&quot;

    $policyDefinitionFileContent = Get-Content -Raw -Path $PolicyFile
    $policyDefinitionFile = ConvertFrom-Json $policyDefinitionFileContent
    $policyDefinitionName = $policyDefinitionFile.properties.displayName

    $parameters = @{}
    $parameters.Add(&quot;Name&quot;, $policyDefinitionName)
    switch ($Scope) {
        &quot;ManagementGroup&quot; {
            $parameters.Add(&quot;ManagementGroupName&quot;, $ScopeName)
        }
        &quot;Subscription&quot; {
            $sub = Get-AzSubscription -SubscriptionName $ScopeName
            $parameters.Add(&quot;SubscriptionId&quot;, $sub.Id)
        }
    }

    $definition = Get-AzPolicyDefinition @parameters -ErrorAction SilentlyContinue

    $parameters.Add(&quot;Policy&quot;, $policyDefinitionFileContent)
    if ($definition) {
        Write-Output &quot;Policy definition already exists, policy will be updated&quot;
    }
    else {
        Write-Output &quot;Policy does not exist&quot;
    }

    New-AzPolicyDefinition @parameters
}&lt;/pre&gt;


&lt;p&gt;Policy definitions can be saved in Azure DevOps as code. The definitions in source control can be deployed via Azure DevOps Pipelines.&lt;/p&gt;


&lt;h2&gt;Prerequisites&lt;/h2&gt;


&lt;p&gt;To be able to start deploying the definitions, we need to have the following in place:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;Service principal in Azure Active Directory&lt;/li&gt;
&lt;li&gt;Service Connection in Azure DevOps&lt;/li&gt;
&lt;li&gt;Access rights in Azure&lt;/li&gt;
&lt;li&gt;Pipeline&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;First couple of prerequisites&lt;/h2&gt;


&lt;p&gt;We will need a service principal to deploy policy definitions via Azure DevOps. Creating this can be done via the portal. When the principal is made, give that principal the correct permissions on the scope where you want to deploy the definitions. I will provide the principal access to the management group where the policies need to be deployed for this article.&lt;/p&gt;


&lt;p&gt;Of course, we can give the principal owner permissions on the scope, but we want to stick to the least privileges. Therefore we provide the principal the &apos;Resource Policy Contributor&apos; role, which is enough for deploying Azure Policies.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/03/image-2.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/03/image-2-1024x212.png&quot; alt=&quot;Role assingment&quot; class=&quot;wp-image-6685&quot; /&gt;&lt;/figure&gt;


&lt;p&gt;With the rights in place, the service connection in Azure DevOps can be configured. In Azure DevOps, create an &quot;Azure Resource Manager&quot; service connection and fill in the correct information regarding your platform.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-full&quot;&gt;&lt;a href=&quot;/assets/archive/2022/03/image-3.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/03/image-3.png&quot; alt=&quot;Service Connection&quot; class=&quot;wp-image-6687&quot; /&gt;&lt;/figure&gt;


&lt;h2&gt; Pipeline&lt;/h2&gt;


&lt;p&gt;Next up is the pipeline. For the pipeline, we will start with an empty one that we save in a GitHub repository, where we also save the policy definition files. From the empty pipeline, remove the default tasks and add an Azure PowerShell task that connects to the Service Connection we created.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-full&quot;&gt;&lt;a href=&quot;/assets/archive/2022/03/image-4.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/03/image-4.png&quot; alt=&quot;Azure PowerShell Task&quot; class=&quot;wp-image-6689&quot; /&gt;&lt;/figure&gt;


&lt;p&gt;Point this task to the correct script file in the repository and ensure the arguments are supplied using variables. The Yaml of the task will look like the snippet below.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;- task: AzurePowerShell@5
  inputs:
    azureSubscription: &apos;Root Management Group Connection&apos;
    ScriptType: &apos;FilePath&apos;
    ScriptPath: &apos;./scripts/azpolicy.ps1&apos;
    ScriptArguments: &apos;-Scope &quot;$(scope)&quot; -ScopeName &quot;$(scopeName)&quot; -PolicyFolder &quot;$(folder)&quot;&apos;
    azurePowerShellVersion: &apos;LatestVersion&apos;
    pwsh: true&lt;/pre&gt;


&lt;p&gt;Bringing this all together will result in a simple pipeline like below.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;trigger:
- main

pool:
  vmImage: ubuntu-latest

variables:
  - name: scope
    value: &quot;ManagementGroup&quot;
  - name: scopeName
    value: &quot;mgName&quot;
  - name: folder
    value: &quot;./policies/deploy&quot;

steps:
- task: AzurePowerShell@5
  inputs:
    displayName: &apos;Deploy Azure Policy Definitions&apos;
    azureSubscription: &apos;Root Management Group Connection&apos;
    ScriptType: &apos;FilePath&apos;
    ScriptPath: &apos;./scripts/azpolicy.ps1&apos;
    ScriptArguments: &apos;-Scope &quot;$(scope)&quot; -ScopeName &quot;$(scopeName)&quot; -PolicyFolder &quot;$(folder)&quot;&apos;
    azurePowerShellVersion: &apos;LatestVersion&apos;
    pwsh: true
&lt;/pre&gt;


&lt;p&gt;Of course, this is not a production-grade solution, but it highlights how to manage your policy definitions in code and how to deploy them. In the following article, we will deploy definitions via GitHub Actions.&lt;/p&gt;


&lt;h2&gt;To be continued&lt;/h2&gt;</content><author><name>Maik van der Gaag</name></author><category term="Azure" /><category term="Azure DevOps" /><category term="DevOps" /><category term="Azure" /><category term="Azure DevOps" /><category term="Compliance" /><category term="Policy" /><summary type="html">As written in Part 1, policies are used to maintain the state. The Azure portal itself contains a lot of OOTB policies, but you also want to create and deploy your own. This part will go over how to deploy custom policy definitions using Azure DevOps.</summary></entry><entry><title type="html">Building your Azure Policies - Part 1</title><link href="http://localhost:4000/2022/03/building-your-azure-policies-part-1/" rel="alternate" type="text/html" title="Building your Azure Policies - Part 1" /><published>2022-03-17T11:00:00+01:00</published><updated>2022-03-17T11:00:00+01:00</updated><id>http://localhost:4000/2022/03/building-your-azure-policies-part-1</id><content type="html" xml:base="http://localhost:4000/2022/03/building-your-azure-policies-part-1/">&lt;p&gt;Azure Policy is a way of enforcing standards and guardrails and assessing resource compliance. In Azure, the compliance dashboard offers an aggregated view to validate the state of the platform with additional options to see the resources that are not compliant.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/03/image-1.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/03/image-1-1024x358.png&quot; alt=&quot;Azure Policy overview&quot; class=&quot;wp-image-6629&quot; /&gt;&lt;/figure&gt;


&lt;h2 id=&quot;overview&quot;&gt;Policy&lt;/h2&gt;


&lt;p&gt;An Azure Policy itself evaluates resources within Azure based on the rules you specify. The rules are defined in a JSON format and called policy definitions, and policies can also be grouped into so-called policy initiatives. The policies themself can be deployed on several scopes that, of course, keep the standard Azure inheritance in place. The scopes it can be deployed to are:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;Management groups&lt;/li&gt;
&lt;li&gt;Subscriptions&lt;/li&gt;
&lt;li&gt;Resource Groups&lt;/li&gt;
&lt;li&gt;Resources&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If there are resources at a scope that can not comply with the guardrails/standards, these resources can be excluded by defining an exclusion on the policy assignment.&lt;/p&gt;


&lt;p&gt;The Azure Portal offers a lot of policies OOTB, but in many situations, you want to create your own. This is when the policy rules come in.&lt;/p&gt;


&lt;h2&gt;Policy Rule Effects&lt;/h2&gt;


&lt;p&gt;As mentioned above, Azure Policies have rules that have specific effects. At the time of writing this article, the following effects are supported:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Append: &lt;/strong&gt;Append additonal information / fields on the resource. Like appending additional rows to an firewall array.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Audit: &lt;/strong&gt;Log specific information as warning in the activity log.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AuditIfNotExists: &lt;/strong&gt;Audit resource when specific configuration is missing and have gone through the if condition of the rule.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deny: &lt;/strong&gt;Deny creation when some configuration is missing or the configuration is not allowed by the standards.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DeployIfNotExists: &lt;/strong&gt;Deploy resources when not configured. This will trigger an template deployment.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Disabled: &lt;/strong&gt;Disabled effect means that the policy itself is disabled.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Modify: &lt;/strong&gt;Modify an existing deployment to fit the rules specified. This is mainly used to do CRUD operations on properties and tags for subscriptions, resource groups and resources.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;When working with policies and custom policies, it is good to know the order of the evaluation process. The below-ordered list shows this:&lt;/p&gt;


&lt;ol&gt;
&lt;li&gt;Disabled&lt;/li&gt;
&lt;li&gt;Append and Modify&lt;/li&gt;
&lt;li&gt;Deny&lt;/li&gt;
&lt;li&gt;Audit&lt;/li&gt;
&lt;li&gt;AuditIfNotExists and DeployIfNotExists.&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;When are policies evaluated&lt;/h2&gt;


&lt;p&gt;Policies are evaluated on multiple occasions and, depending on the way used, will show results in around 30 minutes:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;Manual / On-demand&lt;/li&gt;
&lt;li&gt;At policy assignment&lt;/li&gt;
&lt;li&gt;When changing a policy assignment&lt;/li&gt;
&lt;li&gt;When exemptions are created or updated.&lt;/li&gt;
&lt;li&gt;Default evaluation cycle (once every 24 hours)&lt;/li&gt;
&lt;li&gt;Resource creation or update&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;For more information about policies, read the &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/governance/policy?WT.mc_id=AZ-MVP-5004255&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Azure Policy documentation&lt;/a&gt;.&lt;/p&gt;


&lt;h2&gt;Creating your own Policy&lt;/h2&gt;


&lt;p&gt;Creating your policy is done using Bicep or writing the definition in JSON. With the use of Bicep, you can use the standard way of deploying the policies. &lt;/p&gt;


&lt;p&gt;We will work on a policy that solves the following problem for this series of posts.&lt;/p&gt;


&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;As a administrator I want to make sure that resources that are tagged as production resources are not able to be changed. Unless specific actions are taken.&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;The above problem can be solved by combining Azure Policies with Azure Resource Locks, especially the read-only lock deployed with the &quot;DeployIfNotExists&quot; effect.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;resource bicepDeployResourceLock &apos;Microsoft.Authorization/policyDefinitions@2021-06-01&apos; = {
  name: &apos;Deploy read-only resource locks based on tags&apos;
  properties: {}
}&lt;/pre&gt;


&lt;p&gt;The first part of the policy in Bicep contains the default information, and the policy itself is specified in the properties property. Let&apos;s discuss that in parts.&lt;/p&gt;


&lt;h3&gt;Policy Metadata&lt;/h3&gt;


&lt;p&gt;The first section is the metadata. The policy metadata contains all the information about the policy that defines the name, description, category, and everything else. With the help of the &apos;securityCenter&apos; part, you can specify additional feedback for Azure Security Center.&lt;/p&gt;


&lt;p&gt;For our use case, these properties are filled with information to identify the policy correctly.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;properties: {
    displayName: &apos;Deploy read-only resource lock on resource groups based on tag&apos;
    description: &apos;Deploy read-only resource lock on resource groups based on tag&apos;
    policyType: &apos;Custom&apos;
    mode: &apos;All&apos;
    metadata: {
      category: &apos;Custom&apos;
      source: &apos;Guardrails&apos;
      version: &apos;0.1.0&apos;
      securityCenter: {
        RemediationDescription: &apos;The resource group should have a resource locks assigned. Go to the resource group and assign a resource lock or adjust the tag value&apos;
        Severity: &apos;High&apos;
      }
    }
    parameters: {...
    }
    policyRule: {...
    }
}&lt;/pre&gt;


&lt;h3&gt;Policy Parameters&lt;/h3&gt;


&lt;p&gt;The second part we will discuss is the parameters. Within the policy parameter section, parameters for the policy itself can be defined. Using this adds the ability to supply information when assigning the policies.&lt;/p&gt;


&lt;p&gt;For this use case, we will define two parameters. The tag name so that we can specify against what tag we want to check within the rule and tag value used to check for the rule to be successful.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;properties: {
    metadata: {...
    }
    parameters: {
      tagName: {
        type: &apos;String&apos;
        metadata: {
          displayName: &apos;Tag Name&apos;
          description: &apos;The Tag name to check against (i.e. Environment CostCenter etc.)&apos;
        }
      }
      tagValue: {
        type: &apos;String&apos;
        metadata: {
          displayName: &apos;Tag Value&apos;
          description: &apos;Value of the tag to audit against (i.e. Prod/UAT/TEST 12345 etc.)&apos;
        }
      }
    }
    policyRule: {...
    }
}&lt;/pre&gt;


&lt;h3&gt;Policy Rule&lt;/h3&gt;


&lt;p&gt;The last part is the most important. This section contains the rule, which is the real heart of the policy. This section defines where to check against and what action (effect) is handled.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;properties: {
    metadata: {...
    }
    parameters: {...
    }
    policyRule: {
      if: {
        allOf: [
          {
            field: &apos;type&apos;
            equals: &apos;Microsoft.Resources/subscriptions/resourceGroups&apos;
          }
          {
            field: &apos;[concat(\&apos;tags[\&apos;, parameters(\&apos;tagName\&apos;), \&apos;]\&apos;)]&apos;
            equals: &apos;[parameters(\&apos;tagValue\&apos;)]&apos;
          }
        ]
      }
      then: {
        effect: &apos;deployIfNotExists&apos;
        details: {
          type: &apos;Microsoft.Authorization/locks&apos;
          roleDefinitionIds: [
            &apos;/providers/microsoft.authorization/roleDefinitions/8e3af657-a8ff-443c-a75c-2fe8c4bcb635&apos;
          ]
          existenceCondition: {
            field: &apos;Microsoft.Authorization/locks/level&apos;
            equals: &apos;CanNotDelete&apos;
          }
          deployment: {
            properties: {
              mode: &apos;incremental&apos;
              template: {
                &apos;$schema&apos;: &apos;http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&apos;
                contentVersion: &apos;1.0.0.0&apos;
                parameters: {}
                variables: {}
                resources: [
                  {
                    name: &apos;ReadOnly&apos;
                    type: &apos;Microsoft.Authorization/locks&apos;
                    apiVersion: &apos;2017-04-01&apos;
                    properties: {
                      level: &apos;ReadOnly&apos;
                      notes: &apos;Prevent changes to the resource group and resources&apos;
                    }
                  }
                ]
                outputs: {
                  policy: {
                    type: &apos;string&apos;
                    value: &apos;[concat(\&apos;Added resource lock\&apos;)]&apos;
                  }
                }
              }
            }
          }
        }
      }
    }&lt;/pre&gt;


&lt;p&gt;In the above rule, we do the following: If the field type is of the type resource group and field tags contains a tag with the specified tag name (the parameter) with the value (the parameter) that is configured, then deploy the specified deployment template, which includes the read-only lock.&lt;/p&gt;


&lt;p&gt;The deployment part of the rule contains an ARM template for the deployment.&lt;/p&gt;


&lt;h2&gt;Remediation&lt;/h2&gt;


&lt;p&gt;In Azure, you can also remediate existing resources. In our example, remediating a resource group means that the remediation is done when instructing Azure Policy to remediate the resource. &lt;/p&gt;


&lt;h2&gt;Azure Policy in Bicep&lt;/h2&gt;


&lt;p&gt;The complete policy in Bicep looks like the snapshot below.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;targetScope = &apos;managementGroup&apos;

param policyCategory string = &apos;Custom&apos;
param policySource string = &apos;Guardrails&apos;

resource bicepDeployResourceLock &apos;Microsoft.Authorization/policyDefinitions@2021-06-01&apos; = {
  name: &apos;Deploy read-only resource locks based on tags&apos;
  properties: {
    displayName: &apos;Deploy read-only resource lock on resource groups based on tag&apos;
    description: &apos;Deploy read-only resource lock on resource groups based on tag&apos;
    policyType: &apos;Custom&apos;
    mode: &apos;All&apos;
    metadata: {
      category: policyCategory
      source: policySource
      version: &apos;0.1.0&apos;
      securityCenter: {
        RemediationDescription: &apos;The resource group should have a read-only resource locks assigned. Go to the resource group and assign a resource lock or adjust the tag value&apos;
        Severity: &apos;High&apos;
      }
    }
    parameters: {
      tagName: {
        type: &apos;String&apos;
        metadata: {
          displayName: &apos;Tag Name&apos;
          description: &apos;The Tag name to audit against (i.e. Environment CostCenter etc.)&apos;
        }
      }
      tagValue: {
        type: &apos;String&apos;
        metadata: {
          displayName: &apos;Tag Value&apos;
          description: &apos;Value of the tag to audit against (i.e. Prod/UAT/TEST 12345 etc.)&apos;
        }
      }
    }
    policyRule: {
      if: {
        allOf: [
          {
            field: &apos;type&apos;
            equals: &apos;Microsoft.Resources/subscriptions/resourceGroups&apos;
          }
          {
            field: &apos;[concat(\&apos;tags[\&apos;, parameters(\&apos;tagName\&apos;), \&apos;]\&apos;)]&apos;
            equals: &apos;[parameters(\&apos;tagValue\&apos;)]&apos;
          }
        ]
      }
      then: {
        effect: &apos;deployIfNotExists&apos;
        details: {
          type: &apos;Microsoft.Authorization/locks&apos;
          roleDefinitionIds: [
            &apos;/providers/microsoft.authorization/roleDefinitions/8e3af657-a8ff-443c-a75c-2fe8c4bcb635&apos;
          ]
          existenceCondition: {
            field: &apos;Microsoft.Authorization/locks/level&apos;
            equals: &apos;ReadOnly&apos;
          }
          deployment: {
            properties: {
              mode: &apos;incremental&apos;
              template: {
                &apos;$schema&apos;: &apos;http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&apos;
                contentVersion: &apos;1.0.0.0&apos;
                parameters: {}
                variables: {}
                resources: [
                  {
                    name: &apos;ReadOnly&apos;
                    type: &apos;Microsoft.Authorization/locks&apos;
                    apiVersion: &apos;2020-05-01&apos;
                    properties: {
                      level: &apos;ReadOnly&apos;
                      notes: &apos;Prevent changed of the resource group or its resources&apos;
                    }
                  }
                ]
                outputs: {
                  policy: {
                    type: &apos;string&apos;
                    value: &apos;[concat(\&apos;Added resource lock\&apos;)]&apos;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

output policyDefId string = bicepDeployResourceLock.id&lt;/pre&gt;


&lt;h2&gt;Deploy the Azure Policy&lt;/h2&gt;


&lt;p&gt;When the policy is defined in Bicep, it can quickly be deployed with the standard deployment commands on the scope you want. The below snippet shows how to deploy the file on the management group scope.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;$tempFile = &quot;..\policy.bicep&quot;
$mgId = &quot;mgid&quot;

New-AzManagementGroupDeployment -Name &quot;DeployPolicy&quot; -ManagementGroupId $mgId -TemplateFile $tempFile -Location &quot;WestEurope&quot;&lt;/pre&gt;


&lt;p&gt;The definition can also be defined in JSON. When expressed in JSON, the structure is the same. The snipped below shows it defined in JSON.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;{
 &quot;properties&quot;: {
  &quot;displayName&quot;: &quot;Deploy read-only resource lock on resource groups based on tag&quot;,
  &quot;policyType&quot;: &quot;Custom&quot;,
   &quot;mode&quot;: &quot;All&quot;,
    &quot;metadata&quot;: {
      &quot;category&quot;: &quot;policyCategory&quot;,
      &quot;source&quot;: &quot;policySource&quot;,
      &quot;version&quot;: &quot;0.1.0&quot;,
      &quot;securityCenter&quot;: {
        &quot;RemediationDescription&quot;: &quot;The resource group should have a read-only resource locks assigned. Go to the resource group and assign a resource lock or adjust the tag value&quot;,
        &quot;Severity&quot;: &quot;High&quot;
      }
    },
  &quot;parameters&quot;: {
   &quot;tagName&quot;: {
    &quot;type&quot;: &quot;String&quot;,
    &quot;metadata&quot;: {
     &quot;displayName&quot;: &quot;Tag Name&quot;,
     &quot;description&quot;: &quot;The name of the tag to check against.&quot;
    }
   },
   &quot;tagValue&quot;: {
    &quot;type&quot;: &quot;String&quot;,
    &quot;metadata&quot;: {
     &quot;displayName&quot;: &quot;Tag Value&quot;,
     &quot;description&quot;: &quot;Value of the tag to check against&quot;
    }
   }
  },
  &quot;policyRule&quot;: {
   &quot;if&quot;: {
    &quot;allOf&quot;: [
     {
      &quot;field&quot;: &quot;type&quot;,
      &quot;equals&quot;: &quot;Microsoft.Resources/subscriptions/resourceGroups&quot;
     },
     {
      &quot;field&quot;: &quot;[concat(&apos;tags[&apos;, parameters(&apos;tagName&apos;), &apos;]&apos;)]&quot;,
      &quot;equals&quot;: &quot;[parameters(&apos;tagValue&apos;)]&quot;
     }
    ]
   },
   &quot;then&quot;: {
    &quot;effect&quot;: &quot;deployIfNotExists&quot;,
    &quot;details&quot;: {
     &quot;type&quot;: &quot;Microsoft.Authorization/locks&quot;,
     &quot;roleDefinitionIds&quot;: [
      &quot;/providers/microsoft.authorization/roleDefinitions/8e3af657-a8ff-443c-a75c-2fe8c4bcb635&quot;
     ],
     &quot;existenceCondition&quot;: {
      &quot;field&quot;: &quot;Microsoft.Authorization/locks/level&quot;,
      &quot;equals&quot;: &quot;ReadOnly&quot;
     },
     &quot;deployment&quot;: {
      &quot;properties&quot;: {
       &quot;mode&quot;: &quot;incremental&quot;,
       &quot;template&quot;: {
        &quot;$schema&quot;: &quot;http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&quot;,
        &quot;contentVersion&quot;: &quot;1.0.0.0&quot;,
        &quot;parameters&quot;: {},
        &quot;variables&quot;: {},
        &quot;resources&quot;: [
         {
          &quot;name&quot;: &quot;ReadOnly&quot;,
          &quot;type&quot;: &quot;Microsoft.Authorization/locks&quot;,
          &quot;apiVersion&quot;: &quot;2017-04-01&quot;,
          &quot;properties&quot;: {
           &quot;level&quot;: &quot;ReadOnly&quot;,
           &quot;notes&quot;: &quot;Prevent changes of the resourceGroup and its resources&quot;
          }
         }
        ],
        &quot;outputs&quot;: {
         &quot;policy&quot;: {
          &quot;type&quot;: &quot;string&quot;,
          &quot;value&quot;: &quot;[concat(&apos;Added resource lock&apos;)]&quot;
         }
        }
       }
      }
     }
    }
   }
  }
 }
}&lt;/pre&gt;


&lt;p&gt;With the help of the below PowerShell function, the policy definition can be deployed to the Azure Platform.&lt;/p&gt;


&lt;pre class=&quot;highlight&quot;&gt;[CmdletBinding()]
Param(
  [Parameter(Mandatory = $true)]
  [ValidateSet(&apos;Subscription&apos;, &apos;Managementgroup&apos;)]
  [string]$Scope,
  [Parameter(Mandatory = $true)]
  [string]$ScopeName,
  [Parameter(Mandatory = $true)]
  [string]$PolicyFile,
  [Parameter(Mandatory = $false)]
  [string]$RoleIds
)

$policyDefinitionFileContent = Get-Content -Raw -Path $PolicyFile
$policyDefinitionFile = ConvertFrom-Json $policyDefinitionFileContent
$policyDefinitionName = $policyDefinitionFile.properties.displayName

$parameters = @{}
$parameters.Add(&quot;Name&quot;, $policyDefinitionName)
switch ($Scope) {
    &quot;ManagementGroup&quot; {
      $parameters.Add(&quot;ManagementGroupName&quot;, $ScopeName)
    }
    &quot;Subscription&quot; {
        $sub = Get-AzSubscription -SubscriptionName $ScopeName
        $parameters.Add(&quot;SubscriptionId&quot;, $sub.Id)
    }
}

$definition = Get-AzPolicyDefinition @parameters -ErrorAction SilentlyContinue

$parameters.Add(&quot;Policy&quot;, $policyDefinitionFileContent)
if($definition){
    Write-Output &quot;Policy definition already exists, policy will be updated&quot;
}else{
    Write-Output &quot;Policy does not exist&quot;
}

New-AzPolicyDefinition @parameters&lt;/pre&gt;


&lt;h2&gt;To be continued&lt;/h2&gt;</content><author><name>Maik van der Gaag</name></author><category term="Azure" /><category term="Azure" /><category term="Compliance" /><category term="Policy" /><summary type="html">Azure Policy is a way of enforcing standards and guardrails and assessing resource compliance. In Azure, the compliance dashboard offers an aggregated view to validate the state of the platform with additional options to see the resources that are not compliant.</summary></entry><entry><title type="html">Azure Costs Analysis preview with Anomaly detection</title><link href="http://localhost:4000/2022/03/azure-costs-analysis-preview-with-anomaly-detection/" rel="alternate" type="text/html" title="Azure Costs Analysis preview with Anomaly detection" /><published>2022-03-07T14:38:00+01:00</published><updated>2022-03-07T14:38:00+01:00</updated><id>http://localhost:4000/2022/03/azure-costs-analysis-preview-with-anomaly-detection</id><content type="html" xml:base="http://localhost:4000/2022/03/azure-costs-analysis-preview-with-anomaly-detection/">&lt;p&gt;Microsoft has released new functionality in public preview to manage the costs of Azure subscriptions. This new functionality gives excellent insights into the costs and lets you detect any anomaly of the expenses on those subscriptions.&lt;/p&gt;


&lt;h2&gt;New Cost Analysis Preview&lt;/h2&gt;


&lt;p&gt;The new cost analysis preview blade shows the Azure resources in a different overview than before. This new overview gives you more insight into your data and your costs.&lt;/p&gt;


&lt;h3&gt;Azure Cost Analysis Preview&lt;/h3&gt;


&lt;p&gt;To use the cost analysis preview, go to the following &lt;a href=&quot;https://preview.portal.azure.com/?feature.campaign=cav3#blade/Microsoft_Azure_CostManagement/Menu/costanalysisv3&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;link&lt;/a&gt;. On this blade, select the appropriate scope.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image is-resized&quot;&gt;&lt;img src=&quot;/assets/archive/2022/03/image-2-1024x226.png&quot; alt=&quot;Cost Analysis Preview&quot; width=&quot;840&quot; height=&quot;185&quot; /&gt;&lt;/figure&gt;


&lt;p&gt;The overview offers the option to report on and analyze your cloud costs and review critical insights to understand better and control spending patterns. This is accomplished on four levels:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;Resource Groups&lt;/li&gt;
&lt;li&gt;Subscriptions&lt;/li&gt;
&lt;li&gt;Services&lt;/li&gt;
&lt;li&gt;Reservations&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;All four overviews offer great insights. I love the services overview where you see the costs per service and can view the expenses underneath it. For example, bandwidth costs and VPN gateway costs.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/03/image.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/03/image-1024x474.png&quot; alt=&quot;Services costs analysis&quot; class=&quot;wp-image-6605&quot; /&gt;&lt;/figure&gt;


&lt;h2&gt;Anomaly detection&lt;/h2&gt;


&lt;p&gt;The costs analysis preview now also includes anomaly detection. To better understand the functionality, we should also know what an anomaly is. If we look into a dictionary, we will find something like:&lt;/p&gt;


&lt;ul&gt;
&lt;li&gt;Something different, abnormal, peculiar, or not easily classified&lt;strong&gt;:&amp;nbsp;&lt;/strong&gt;something&amp;nbsp;anomalous.&lt;/li&gt;
&lt;li&gt;Deviation from the common rule&lt;strong&gt;:&amp;nbsp;&lt;/strong&gt;irregularity&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It means that a cost increase of 5000 euros could be an anomaly regarding cost management. But that would not be the case if the billing was raised monthly, for example.&lt;/p&gt;


&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;a href=&quot;/assets/archive/2022/02/image-2.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/03/image-2-1024x226.png&quot; alt=&quot;&quot; class=&quot;wp-image-6591&quot; /&gt;&lt;br /&gt;
&lt;figcaption&gt;After selecting a specific view for the first time, the preview is enabled, and you will get more insights regarding the Azure costs. When using the preview for the first time, you will see the below screenshot.&lt;/figcaption&gt;
&lt;/figure&gt;


&lt;figure class=&quot;wp-block-image size-full&quot;&gt;&lt;a href=&quot;/assets/archive/2022/02/image-3.png&quot; /&gt;&lt;img src=&quot;/assets/archive/2022/03/image-3.png&quot; alt=&quot;&quot; class=&quot;wp-image-6593&quot; /&gt;&lt;br /&gt;
&lt;figcaption&gt;Opening up the blade after a day will show any anomaly, if there are any.&lt;/figcaption&gt;
&lt;/figure&gt;</content><author><name>Maik van der Gaag</name></author><category term="Azure" /><category term="Azure" /><category term="Costs" /><category term="Preview" /><summary type="html">Microsoft has released new functionality in public preview to manage the costs of Azure subscriptions. This new functionality gives excellent insights into the costs and lets you detect any anomaly of the expenses on those subscriptions.</summary></entry></feed>